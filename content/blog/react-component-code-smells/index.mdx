---
title: React component code smells
date: '2020-08-13T20:17:00.000Z'
updated: '2020-10-24T20:00:00.000Z'
description: 'Code smells to avoid in your React components'
dev: ''
state: 'growing'
---

A collection of things I consider code smells in react components. All opinionated of course, so would love to hear if you (dis)agree or have other suggestions.

- [Too many props](#too-many-props)
- [Incompatible props](#incompatible-props)
- [Shared state](#shared-state)
- [Copying props into state](#props-in-state)
- [Large "data" props](#large-props)
- [(Not) prop drilling](#prop-drilling)
- [Returning JSX from functions](#jsx-returns)
- [Multiple booleans for state](#multiple-booleans)
- [Too many useState in a component](#many-usestate)
- [Large useEffect](#large-useeffect)

## <a id="too-many-props"></a> Too many props

Passing too many props into a single component may be a sign that the component should be split up.

How many is too many you may ask? Well, _too many_ is very arbitrary so "it depends". You might find yourself in a situation where a component should have 20 props or more, and still be satisfied that it only does one thing. But when you do stumble upon a component that have many props or you get the urge to add _just one more_ to the already long list of props there's a couple of things to consider:

#### Is this component doing multiple things?

Like functions, components should do _one thing well_ so it's always good to check if the it's possible to split the component into multiple smaller components. For example if the component is doing too much or if it has [incompatible props](#incompatible-props).

#### Could I use composition?

A pattern that is very good but often overlooked is to compose components instead of handling all logic inside just one. Let's say we have a component that handles a user application to some organisation:

```jsx
<ApplicationForm
  user={userData}
  organisation={organisationData}
  categories={categoriesData}
  locations={locationsData}
  onSubmit={handleSubmit}
  onCancel={handleCancel}
  ...
/>
```

Looking at the props of this component we can see that all of them are related to what the component does, but there's still room to improve this by moving some of the components responsibility to it's children instead:

```jsx
<ApplicationForm onSubmit={handleSubmit} onCancel={handleCancel}>
  <ApplicationUserForm user={userData} />
  <ApplicationOrganisationForm organisation={organisationData} />
  <ApplicationCategoryForm categories={categoriesData} />
  <ApplicationLocationsForm locations={locationsData} />
</ApplicationForm>
```

Now we've made sure that the `ApplicationForm` only handles it's most narrow responsibility, submitting and cancelling the form. The child components can handle everything related to their part of the bigger picture. This is also a great opportunity to use [React Context](https://reactjs.org/docs/context.html) for the communication between the children and their parent.

#### Am I passing down many 'configuration'-props?

In some cases it's a good idea to group together props into an options object, for example to make it easier to swap this configuration. If we have a component that displays some sort of grid or table:

```jsx
<Grid
  data={gridData}
  pagination={false}
  autoSize={true}
  enableSort={true}
  sortOrder="desc"
  disableSelection={true}
  infiniteScroll={true}
  ...
/>
```

All of these props except `data` could be considered _configuration_. If we wanted to make all of these dynamic we would either have to manage a lot of lonely variables or put them in an object and then pass them down like `pagination={options.pagination}`. While this works I think it's a bit cleaner to change the `Grid` so that it accepts an `options` prop instead.

```jsx
const options = {
  pagination: false,
  autoSize: true,
  enableSort: true,
  sortOrder: 'desc',
  disableSelection: true,
  infiniteScroll: true,
  ...
}

<Grid
  data={gridData}
  options={options}
/>
```

This also means that it's easier to exclude configuration options we don't want to use when swapping between different `options`, for example excluding `pagination` from some options and include it in others.

## <a id="incompatible-props"></a> Incompatible props

Avoid passing props that are incompatible with each other.

For example we might start by creating a common `<Input />` component that is intended to just handle text, but after a while we also add the possibility to use it for phone numbers as well. The implementation could look something like this:

```jsx
function Input({ value, isPhoneNumberInput, autoCapitalize }) {
  if (autoCapitalize) capitalize(value)

  return <input value={value} type={isPhoneNumberInput ? 'tel' : 'text'} />
}
```

The problem with this is that the props `isPhoneNumberInput` and `autoCapitalize` don't make sense together. We can't really capitalize phone numbers.

One solution to this is to break the component up into multiple smaller components. If we still have some logic we want to share between them, we can move it to a [custom hook](https://reactjs.org/docs/hooks-custom.html):

```jsx
function TextInput({ value, autoCapitalize }) {
  if (autoCapitalize) capitalize(value)
  useSharedInputLogic()

  return <input value={value} type="text" />
}

function PhoneNumberInput({ value }) {
  useSharedInputLogic()

  return <input value={value} type="tel" />
}
```

While this example is a bit contrived, finding props that are incompatible with each other is usually a good indication that you should check if the component needs to be broken apart.

## <a id="shared-state"></a> Shared state

ie duplicating the component and it shares state it shouldn't
Navbar never duplicated? Think again, animations! ðŸ’«

Fixes:

- Remove the shared state, make sure you can use multiple instances of the component

## <a id="props-in-state"></a> Copying props into state

Don't stop the data flow by copying props into state.

Consider this component:

```jsx
function Button({ text }) {
  const [buttonText] = useState(text)

  return <button>{buttonText}</button>
}
```

By passing the `text` prop as the it's initial value of useState the component now practically _ignores_ all updated values of `text`. If the `text` prop was updated the component would still render its first value. WHY IS THIS A BAD THING

A concrete example of this happening is when we want to derive some new value from a prop and especially if this requires some slow calculation. In the example below we run the `formatTextSlowly` function to format our `text`-prop, which takes a lot of time to execute.

```jsx
function Button({ text }) {
  const [formattedText] = useState(formatTextSlowly(text))

  return <button>{formattedText}</button>
}
```

By putting it into state we've solved the issue that it will rerun unneccesarily but like above we've also stopped the component from updating. A better way to solving this issue is using the [useMemo hook](https://reactjs.org/docs/hooks-reference.html#usememo) to _memoize_ the result:

```jsx
function Button({ text }) {
  const formattedText = useMemo(() => formatTextSlowly(text), [text])

  return <button>{formattedText}</button>
}
```

Now `formatTextSlowly` only runs when `text` changes and we haven't stopped the component from updating.

> Sometimes we do need a prop where all updates to it are ignored, for example a color picker where we need the option to set a initially picked color but when the user have picked a color we don't want an update to override the users choice. In this case it's totally fine to copy the prop into state, but to indicate this behaviour to the user most developers prefix the prop with either initial or default (`initialColor`/`defaultColor`).

Further reading: [Writing resilient components by Dan Abramov](https://overreacted.io/writing-resilient-components/).

## <a id="large-props"></a> Large "data" props

Passing data instead of composing (See Composable components â†’ tabs)

## <a id="prop-drilling"></a> (Not) prop drilling

Prop drilling is usually just fine but sometimes there's better alternatives.

- Use composition (pass down component as prop)
- Use context api (when state is shared "horizontally")

## <a id="jsx-returns"></a> Returning JSX from functions

Splitting up a components JSX into multiple functions makes it hard to reason about the code, and is a clear example of a time where we probably want to create a new component instead.

> Remember that just because you create a new component you don't have to move it to a new file as well. Sometimes it makes sense to keep multiple components in the same file if they are tightly coupled.

## <a id="multiple-booleans"></a> Multiple booleans for state

Avoid using multiple booleans to represent a components state.

When writing a component and subsequently extending the components functionality it's easy to end up in a situation where you have multiple booleans to indicate which state the component is in. For a small component that does a web request when you click a button you might have something like this:

```jsx
function Component() {
  const [isLoading, setIsLoading] = useState(false)
  const [isFinished, setIsFinished] = useState(false)
  const [hasError, setHasError] = useState(false)

  const fetchSomething = () => {
    setIsLoading(true)

    fetch(url)
      .then(() => {
        setIsLoading(false)
        setIsFinished(true)
      })
      .catch(() => {
        setHasError(true)
      })
  }

  if (isLoading) return <Loader />
  if (hasError) return <Error />
  if (isFinished) return <Success />

  return <button onClick={fetchSomething} />
}
```

When the button is we set `isLoading` to true and do a web request with fetch. When the request returns we either set `isLoading` to false and `isFinished` to true if the request was successful or set `hasError` to true if there was an error.

While this technically works fine it's hard to reason about what state the component is in and it's more error prone than alternatives. We could also end up in an "impossible state", for example if we accidentally set both `isLoading` and `isFinished` to true at the same time.

The solution is to manage the state with an `enum` instead. In other languages enums are a way to define a variable that is only allowed to be set to a predefined set of constant values, and while enums doesn't technically exist in Javascript we can use a string and still get a lot of benefit:

```jsx
function Component() {
  const [state, setState] = useState('idle')

  const fetchSomething = () => {
    setState('loading')

    fetch(url)
      .then(() => {
        setState('finished')
      })
      .catch(() => {
        setState('error')
      })
  }

  if (state === 'loading') return <Loader />
  if (state === 'error') return <Error />
  if (state === 'finished') return <Success />

  return <button onClick={fetchSomething} />
}
```

By doing it this way we've removed the possibility for impossible states and made it **much** easier to reason about this component. Finally, if you're using some sort of type system like TypeScript it's even better since you can specify the possible states:

```ts
const [state, setState] = useState<'idle' | 'loading' | 'error' | 'finished'>('idle')
```

## <a id="many-usestate"></a> Too many useState

Many many useState

Fixes:

- useReducer

## <a id="large-useeffect"></a> Large useEffect

Avoid large `useEffect`s that do multiple things. They make your code error prone and harder to reason about.

A mistake that I made a lot when hooks was released was putting to many things into a single `useEffect`. For example:

```jsx
function Post({ id, unlisted }) {
  ...

  useEffect(() => {
    fetch(`/posts/${id}`).then(/* do something */)

    setVisibility(unlisted)
  }, [id, unlisted])

  ...
}
```

While this effect isn't that large it still do multiple things. When the `unlisted` prop changes we will fetch the post even if `id` hasn't changed.

To catch errors like this I try to describe the effects I write by saying "when `[dependencies]` change do _this_" to myself. Applying that to the effect above we get "when `id` **or** `unlisted` changes, fetch the post **and** update visibility". If this sentence contains the words "**or**" or "**and**" it usually points to a problem.

Breaking this effect up into two effects instead:

```jsx
function Post({ id, unlisted }) {
  ...

  useEffect(() => { // when id changes fetch the post
    fetch(`/posts/${id}`).then(/* ... */)
  }, [id])

  useEffect(() => { // when unlisted changes update visibility
    setVisibility(unlisted)
  }, [unlisted])

  ...
}
```

By doing this we've reduced the complexity of our component, made it easier to reason about and lowered the risk of creating bugs.

## Wrapping up

...
