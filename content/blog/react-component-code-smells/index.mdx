---
title: React component code smells
date: '2020-08-13T20:17:00.000Z'
description: 'Code smells to avoid in your React components'
dev: ''
state: 'budding'
---

A collection of things I consider code smells in react components. All opinionated, but would love to hear if you (dis)agree or have other suggestions.

## Too many props

Passing too many props into a single component may be a sign that the component should be split up.

Fixes:

- Pass down an `options` object
- Break the component up into multiple components
- Use composition

## Incompatible props

Props that don't work together, for example `autoCapitalize=true` and `type=tel`

Fixes:

- Break up into multiple components

## Shared state

ie duplicating the component and it shares state it shouldn't
Navbar never duplicated? Think again, animations! ðŸ’«

Fixes:

- Remove the shared state, make sure you can use multiple instances of the component

## Copying props into state

Don't stop the data flow: For example copying props into state, meaning that when props change the state isn't updated. (Constructor: state.x = prop.x)

When intentional, use standard naming like initialColor or defaultColor.

Reading: [Writing resilient components by Dan Abramov](https://overreacted.io/writing-resilient-components/).

## Large "data" props

Passing data instead of composing (See Composable components â†’ tabs)

## (Not) prop drilling

Prop drilling is usually just fine but sometimes there's better alternatives.

- Use composition (pass down component as prop)
- Use context api (when state is shared "horizontally")

## Returning JSX from functions

Splitting up a compoents JSX into multiple functions makes it hard to reason about the code, and is a clear example of a time where we probably want to create a new component instead.

Components doesn't have to be moved to separate file, if tightly coupled?

## Multiple booleans for state

Avoid using multiple booleans to represent a components state. Most of the time it's easier to replace them with a single enum/string.

Fixes:

- `useState('loading')`

## Too many useState in a component

Many many useState

Fixes:

- useReducer

## Large useEffect

Large useEffects, makes it hard to reason about the code. With smaller useEffects it's more natural:
"When [dependencies] change do -this-"

Fixes:

- Break up into multiple smaller useEffects
