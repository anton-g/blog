---
title: React component code smells
date: '2020-08-13T20:17:00.000Z'
updated: '2020-08-22T22:00:00.000Z'
description: 'Code smells to avoid in your React components'
dev: ''
state: 'budding'
---

A collection of things I consider code smells in react components. All opinionated of course, so would love to hear if you (dis)agree or have other suggestions.

- [Too many props](#too-many-props)
- [Incompatible props](#incompatible-props)
- [Shared state](#shared-state)
- [Copying props into state](#props-in-state)
- [Large "data" props](#large-props)
- [(Not) prop drilling](#prop-drilling)
- [Returning JSX from functions](#jsx-returns)
- [Multiple booleans for state](#multiple-booleans)
- [Too many useState in a component](#many-usestate)
- [Large useEffect](#large-useeffect)

## <a id="too-many-props"></a> Too many props

Passing too many props into a single component may be a sign that the component should be split up.

Fixes:

- Pass down an `options` object
- Break the component up into multiple components. Components should do _one thing_ so check for [Incompatible props](#incompatible-props).
- Use composition

## <a id="incompatible-props"></a> Incompatible props

Avoid passing props that are incompatible with each other.

For example we might start by creating a common `<Input />` component that is intended to just handle text, but after a while we also add the possibility to use it for phone numbers as well. The implementation could look something like this:

```jsx
function Input({ value, isPhoneNumberInput, autoCapitalize }) {
  if (autoCapitalize) capitalize(value)

  return <input value={value} type={isPhoneNumberInput ? 'tel' : 'text'} />
}
```

The problem with this is that the props `isPhoneNumberInput` and `autoCapitalize` don't make sense together. We can't really capitalize phone numbers.

One solution to this is to break the component up into multiple smaller components. If we still have some logic we want to share between them, we can move it to a [custom hook](https://reactjs.org/docs/hooks-custom.html):

```jsx
function TextInput({ value, autoCapitalize }) {
  if (autoCapitalize) capitalize(value)
  useSharedInputLogic()

  return <input value={value} type="text" />
}

function PhoneNumberInput({ value }) {
  useSharedInputLogic()

  return <input value={value} type="tel" />
}
```

While this example is a bit contrived, finding props that are incompatible with each other is usually a good indication that you should check if the component needs to be broken apart.

## <a id="shared-state"></a> Shared state

ie duplicating the component and it shares state it shouldn't
Navbar never duplicated? Think again, animations! ðŸ’«

Fixes:

- Remove the shared state, make sure you can use multiple instances of the component

## <a id="props-in-state"></a> Copying props into state

Don't stop the data flow: For example copying props into state, meaning that when props change the state isn't updated. (Constructor: state.x = prop.x, useState(prop))

When intentional, use standard naming like initialColor or defaultColor.

Reading: [Writing resilient components by Dan Abramov](https://overreacted.io/writing-resilient-components/).

## <a id="large-props"></a> Large "data" props

Passing data instead of composing (See Composable components â†’ tabs)

## <a id="prop-drilling"></a> (Not) prop drilling

Prop drilling is usually just fine but sometimes there's better alternatives.

- Use composition (pass down component as prop)
- Use context api (when state is shared "horizontally")

## <a id="jsx-returns"></a> Returning JSX from functions

Splitting up a components JSX into multiple functions makes it hard to reason about the code, and is a clear example of a time where we probably want to create a new component instead.

Components doesn't have to be moved to separate file, if tightly coupled?

## <a id="multiple-booleans"></a> Multiple booleans for state

Avoid using multiple booleans to represent a components state. Most of the time it's easier to replace them with a single enum/string.

Fixes:

- `useState('loading')`

## <a id="many-usestate"></a> Too many useState in a component

Many many useState

Fixes:

- useReducer

## <a id="large-useeffect"></a> Large useEffect

Avoid large `useEffect`s that do multiple things. They make your code error prone and harder to reason about.

A mistake that I made a lot when hooks was released was putting to many things into a single `useEffect`. For example:

```jsx
function Post({ id, unlisted }) {
  ...

  useEffect(() => {
    fetch(`/posts/${id}`).then(/* do something */)

    setVisibility(unlisted)
  }, [id, unlisted])

  ...
}
```

While this effect isn't that large it still do multiple things. When the `unlisted` prop changes we will fetch the post even if `id` hasn't changed.

To catch errors like this I try to describe the effects I write by saying "when `[dependencies]` change do _this_" to myself. Applying that to the effect above we get "when `id` **or** `unlisted` changes, fetch the post **and** update visibility". If this sentence contains the words "**or**" or "**and**" it usually points to a problem.

Breaking this effect up into two effects instead:

```jsx
function Post({ id, unlisted }) {
  ...

  useEffect(() => { // when id changes fetch the post
    fetch(`/posts/${id}`).then(/* do something */)
  }, [id])

  useEffect(() => { // when unlisted changes update visibility
    setVisibility(unlisted)
  }, [unlisted])

  ...
}
```
